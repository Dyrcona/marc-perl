<HTML>
<HEAD>
<TITLE>MARC.pm - Perl extension to manipulate MAchine Readable Cataloging records.</TITLE>
<LINK REV="made" HREF="mailto:root@porky.devel.redhat.com">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<UL>

		<LI><A HREF="#Types_of_Conversions_">Types of Conversions:</A>
		<LI><A HREF="#Downloading_and_Installing">Downloading and Installing</A>
		<LI><A HREF="#Todo">Todo</A>
		<LI><A HREF="#Web_Interface">Web Interface</A>
		<LI><A HREF="#Option_Templates">Option Templates</A>
	</UL>

	<LI><A HREF="#METHODS">METHODS</A>
	<UL>

		<LI><A HREF="#new_">new()</A>
		<LI><A HREF="#openmarc_">openmarc()</A>
		<LI><A HREF="#nextmarc_">nextmarc()</A>
		<LI><A HREF="#nextrec_">nextrec()</A>
		<LI><A HREF="#closemarc_">closemarc()</A>
		<LI><A HREF="#add_map_">add_map()</A>
		<LI><A HREF="#rebuild_map">rebuild_map</A>
		<LI><A HREF="#rebuild_map_all">rebuild_map_all</A>
		<LI><A HREF="#getfields">getfields</A>
		<LI><A HREF="#marc_count_">marc_count()</A>
		<LI><A HREF="#getfirstvalue_">getfirstvalue()</A>
		<LI><A HREF="#getvalue_">getvalue()</A>
		<LI><A HREF="#unpack_ldr_record_">unpack_ldr($record)</A>
		<LI><A HREF="#get_hash_ldr_record_">get_hash_ldr($record)</A>
		<LI><A HREF="#pack_ldr_record_">pack_ldr($record)</A>
		<LI><A HREF="#bib_format_record_">bib_format($record)</A>
		<LI><A HREF="#unpack_008_record_">unpack_008($record)</A>
		<LI><A HREF="#get_hash_008_record_">get_hash_008($record)</A>
		<LI><A HREF="#pack_008_record_">pack_008($record)</A>
		<LI><A HREF="#deletefirst_">deletefirst()</A>
		<LI><A HREF="#deletemarc_">deletemarc()</A>
		<LI><A HREF="#updatefirst_">updatefirst()</A>
		<LI><A HREF="#updatefields_">updatefields()</A>
		<LI><A HREF="#getmatch_">getmatch()</A>
		<LI><A HREF="#insertpos_">insertpos()</A>
		<LI><A HREF="#selectmarc_">selectmarc()</A>
		<LI><A HREF="#searchmarc_">searchmarc()</A>
		<LI><A HREF="#createrecord_">createrecord()</A>
		<LI><A HREF="#getupdate_">getupdate()</A>
		<LI><A HREF="#updaterecord_">updaterecord()</A>
		<LI><A HREF="#addfield_">addfield()</A>
		<LI><A HREF="#add_005s_">add_005s()</A>
		<LI><A HREF="#output_">output()</A>
		<LI><A HREF="#usmarc_default_">usmarc_default()</A>
		<LI><A HREF="#ustext_default_">ustext_default()</A>
		<LI><A HREF="#as_string_">as_string()</A>
		<LI><A HREF="#from_string_">from_string()</A>
	</UL>

	<LI><A HREF="#EXAMPLES">EXAMPLES</A>
	<LI><A HREF="#NOTES">NOTES</A>
	<LI><A HREF="#AUTHORS">AUTHORS</A>
	<LI><A HREF="#SEE_ALSO">SEE ALSO</A>
	<LI><A HREF="#COPYRIGHT">COPYRIGHT</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<HR>
<H1><A NAME="NAME">NAME</A></H1>
<P>
MARC.pm - Perl extension to manipulate MAchine Readable Cataloging records.

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<PRE>  use MARC;
</PRE>
<P>
<PRE>        # constructors
  $x=MARC-&gt;new();
  $x=MARC-&gt;new(&quot;filename&quot;,&quot;fileformat&quot;);
  $x-&gt;openmarc({file=&gt;&quot;makrbrkr.mrc&quot;,'format'=&gt;&quot;marcmaker&quot;,
                increment=&gt;&quot;5&quot;, lineterm=&gt;&quot;\n&quot;,
                charset=&gt;\%char_hash});
  $record_num=$x-&gt;createrecord({leader=&gt;&quot;00000nmm  2200000 a 4500&quot;});
</PRE>
<P>
<PRE>        # input/output operations
  $y=$x-&gt;nextmarc(10);                  # increment
  $x-&gt;closemarc();
  print $x-&gt;marc_count();
  $x-&gt;deletemarc({record=&gt;'2',field=&gt;'110'});
  $y=$x-&gt;selectmarc(['4','21-50','60']);
</PRE>
<P>
<PRE>        # character translation
  my %inc = %{$x-&gt;usmarc_default()};    # MARCMaker input charset
  my %outc = %{$x-&gt;ustext_default()};   # MARCBreaker output charset
</PRE>
<P>
<PRE>        # data queries
  @records = $x-&gt;searchmarc({field=&gt;&quot;245&quot;});
  @records = $x-&gt;searchmarc({field=&gt;&quot;260&quot;,subfield=&gt;&quot;c&quot;,
                             regex=&gt;&quot;/19../&quot;});
  @records = $x-&gt;searchmarc({field=&gt;&quot;245&quot;,notregex=&gt;&quot;/huckleberry/i&quot;});
  @results = $x-&gt;getvalue({record=&gt;'12',field=&gt;'856',subfield=&gt;'u'});
</PRE>
<P>
<PRE>        # header and control field operations
  $rldr = $x-&gt;unpack_ldr($record);
  print &quot;Desc is $rldr-&gt;{Desc}&quot;;
  next if ($x-&gt;bib_format($record) eq 'SERIALS');
  $rff = $x-&gt;unpack_008($record);
  last if ($rff-&gt;{'Date1'}=~/00/ or $rff-&gt;{'Date2'}=~/00/);
</PRE>
<P>
<PRE>        # data modifications
  $x-&gt;addfield({record=&gt;&quot;2&quot;, field=&gt;&quot;245&quot;,
                i1=&gt;&quot;1&quot;, i2=&gt;&quot;4&quot;, ordered=&gt;'y', value=&gt;
                [a=&gt;&quot;The adventures of Huckleberry Finn /&quot;,
                 c=&gt;&quot;Mark Twain ; illustrated by E.W. Kemble.&quot;]});
</PRE>
<P>
<PRE>  my $update245 = {field=&gt;'245',record=&gt;2,ordered=&gt;'y'};
  my @u245 = $x-&gt;getupdate($update245);
  $x-&gt;deletemarc($update245);
  $x-&gt;addfield($update245, @u245_modified);
 
        # outputs
  $y = $x-&gt;output({'format'=&gt;&quot;marcmaker&quot;, charset=&gt;\%outc});
  $x-&gt;output({file=&gt;&quot;&gt;&gt;my_text.txt&quot;,'format'=&gt;&quot;ascii&quot;,record=&gt;2});
  $x-&gt;output({file=&gt;&quot;&gt;my_marcmaker.mkr&quot;,'format'=&gt;&quot;marcmaker&quot;,
              nolinebreak=&gt;'y',lineterm=&gt;'\n'});
  $x-&gt;output({file=&gt;&quot;&gt;titles.html&quot;,'format'=&gt;&quot;html&quot;, 245=&gt;&quot;Title: &quot;});    
</PRE>
<P>
<PRE>        # manipulation of individual marc records.
  @recs = $x[1..$#$x];
  grep {$_-&gt;unpack_ldr() &amp;&amp; 0} @recs;
  @LCs = grep {$_-&gt;unp_ldr{Desc} eq 'a' &amp;&amp;
               $_-&gt;getvalue({field=&gt;'040'}) =~/DLC\c_.DLC/} @recs;
  foreach my $rec (@LCs) {
          print $rec-&gt;output({format=&gt;'usmarc'});
  }
  
        # manipulation as strings.
  foreach my $rec (@LCs) {
          my $stringvar = $rec-&gt;as_string();
          $stringvar=~s[^(
                          100\s # main entries of this stripe..
                          ..\s # (don't care about indicators)
                          \c_.\s*
                          )(\S) # take the first letter..
                        ] [
                        ${1}uc($2) # and upcase it. All authors have 
                                   # upcase first letters in my library.
                        ]xm; # x means 'ignore whitespace and allow
                             # embedded comments'. 
         $rec-&gt;from_string($stringvar);
         my ($i2,$article) = $stringvar =~/245 .(.) \c_.(.{0,9})/;      
         $article = substr($article,0,$i2) if $i2=~/\d/;
         print &quot;article $article is not common&quot; unless $COMMON_ARTS{$article};
  }
         
  
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
MARC.pm is a Perl 5 module for reading in, manipulating, and outputting
bibliographic records in the <EM>USMARC</EM> format. You will need to have Perl 5.004 or greater for MARC.pm to work
properly. Since it is a Perl module you use MARC.pm from one of your own
Perl scripts. To see what sorts of conversions are possible you can try out
a web interface to MARC.pm which will allow you to upload MARC files and
retrieve the results (for details see the section below entitled ``Web
Interface''). 

<P>
However, to get the full functionality you will probably want to install
MARC.pm on your server or PC. MARC.pm can handle both single and batches of
MARC records. The limit on the number of records in a batch is determined
by the memory capacity of the machine you are running. If memory is an
issue for you MARC.pm will allow you to read in records from a batch
gradually. MARC.pm also includes a variety of tools for searching,
removing, and even creating records from scratch.

<P>
<HR>
<H2><A NAME="Types_of_Conversions_">Types of Conversions:</A></H2>
<UL>
<LI>
<P>
MARC -&gt; ASCII : separates the MARC fields out into separate lines

<LI>
<P>
MARC &lt;-&gt; MARCMaker : The MARCMaker format is a format that was developed by
the
<EM>Library of Congress</EM> for use with their DOS based <EM>MARCMaker</EM> and
<EM>MARCBreaker</EM> utilities. This format is particularly useful for making global changes
(ie. with a text editor's search and replace) and then converting back to
MARC (MARC.pm will read properly formatted MARCMaker records). For more
information about the MARCMaker format see <A
HREF="http://lcweb.loc.gov/marc/marcsoft.html">http://lcweb.loc.gov/marc/marcsoft.html</A>


<LI>
<P>
MARC -&gt; HTML : The MARC to HTML conversion creates an HTML file from the
fields and field labels that you supply. You could possibly use this to
create HTML bibliographies from a batch of MARC records. 

<LI>
<P>
MARC &lt;-&gt; XML : XML support is handled by MARC::XML which is a subclass of MARC.pm
and is also available for download from the CPAN.

<LI>
<P>
MARC -&gt; URLS : This conversion will extract URLs from a batch of MARC
records. The URLs are found in the 856 field, subfield u. The HTML page
that is generated can then be used with link-checking software to determine
which URLs need to be repaired. Hopefully library system vendors will soon
support this activity soon and make this conversion unecessary!

</UL>
<P>
<HR>
<H2><A NAME="Downloading_and_Installing">Downloading and Installing</A></H2>
<DL>
<DT><STRONG><A NAME="item_Download">Download</A></STRONG><DD>
<P>
The module is provided in standard CPAN distribution format. It will
extract into a directory MARC-version with any necessary subdirectories.
Change into the MARC top directory. Download the latest version from <A
HREF="http://www.cpan.org/modules/by-module/MARC/">http://www.cpan.org/modules/by-module/MARC/</A>


<DT><STRONG><A NAME="item_Unix">Unix</A></STRONG><DD>
<P>
<PRE>    perl Makefile.PL
    make
    make test
    make install
</PRE>
<DT><STRONG><A NAME="item_Win9x">Win9x/WinNT/Win2000</A></STRONG><DD>
<P>
<PRE>    perl Makefile.PL
    perl test.pl
    perl install.pl
</PRE>
<DT><STRONG><A NAME="item_Test">Test</A></STRONG><DD>
<P>
Once you have installed, you can check if Perl can find it. Change to some
other directory and execute from the command line:

<P>
<PRE>    perl -e &quot;use MARC&quot;
</PRE>
<P>
If you do not get any response that means everything is OK! If you get an
error like <EM>Can't locate method "use" via package MARC</EM>. then Perl is not able to find MARC.pm--double check that the file copied
it into the right place during the install.

</DL>
<P>
<HR>
<H2><A NAME="Todo">Todo</A></H2>
<UL>
<LI>
<P>
Support for other MARC formats (UKMARC, FINMARC, etc).

<LI>
<P>
Create a map and instructions for using and extending the MARC.pm data
structure.

<LI>
<P>
Develop better error catching mechanisms.

<LI>
<P>
Support for MARC &lt;-&gt; Unicode character conversions.

<LI>
<P>
MARC &lt;-&gt; EAD (Encoded Archival Description) conversion?

<LI>
<P>
MARC &lt;-&gt; DC/RDF (Dublin Core Metadata encoded in the Resource Description
Framework)?

</UL>
<P>
<HR>
<H2><A NAME="Web_Interface">Web Interface</A></H2>
<P>
A web interface to MARC.pm is available at <A
HREF="http://marcpm.sourceforge.net/cgi-bin/converter.cgi">http://marcpm.sourceforge.net/cgi-bin/converter.cgi</A>
where you can upload records and observe the results. If you'd like to
check out the cgi script take a look at <A
HREF="http://marcpm.sourceforge.net/documentation/marcpm/converter.txt">http://marcpm.sourceforge.net/documentation/marcpm/converter.txt</A>
However, to get the full functionality you will want to install MARC.pm on
your server or PC.

<P>
<HR>
<H2><A NAME="Option_Templates">Option Templates</A></H2>
<P>
A MARC record is a complex structure. Hence, most of the methods have a
number of options. Since a series of operations frequently uses many the
same options for each method, you can create a single variable that forms a
``template'' for the desired options. The variable points to a hash - and
the hash keys have been selected so the same hash works for all of the
related methods.

<P>
<PRE>    my $loc852 = {record=&gt;1, field=&gt;'852', ordered=&gt;'y'};
    my ($found) = $x-&gt;searchmarc($loc852);
    if (defined $found) {
        my @m852 = $x-&gt;getupdate($loc852);
        $x-&gt;deletemarc($loc852);
            # change @m852 as desired
        $x-&gt;updaterecord($loc852, @m852fix);
    }
    else {
        $x-&gt;addfield($loc852, @m852new);
    }
</PRE>
<P>
The following methods are specifically designed to work together using
<EM>Option Templates</EM>. The <STRONG>required</STRONG> options are shown as <STRONG>bold</STRONG>. Any
<CODE>(default)</CODE> options are shown in parentheses. Although <STRONG>deletemarc()</STRONG>
permits an array for the <EM>record</EM> option, a single <EM>record</EM> should be used in a Template. The <EM>subfield</EM> option must not be used in a Template that uses both <STRONG>deletemarc</STRONG> and one of the methods that acts on a complete <EM>field</EM> like <STRONG>addfield()</STRONG>. The <EM>value</EM> option must not be used with <STRONG>updaterecord()</STRONG>.
 

<P>
<CODE>deletemarc()</CODE> - field (all), record (all), subfield
[supplemental]

<P>
<CODE>searchmarc()</CODE> - <STRONG>field</STRONG>, regex, notregex, subfield [supplemental]

<P>
<CODE>getvalue()</CODE> - <STRONG>record</STRONG>, <STRONG>field</STRONG>, subfield, delimiter [supplemental]

<P>
<CODE>getfirstvalue()</CODE> - <STRONG>record</STRONG>, <STRONG>field</STRONG>, subfield, delimiter [supplemental]

<P>
<CODE>getupdate()</CODE> - <STRONG>record</STRONG>, <STRONG>field</STRONG>



<P>
<CODE>getfields()</CODE> - <STRONG>record</STRONG>, <STRONG>field</STRONG> 

 

<P>
<CODE>addfield()</CODE> - <STRONG>record</STRONG>, <STRONG>field</STRONG>, i1 (' '), i2 (' '), value, ordered ('y')

<P>
<CODE>updaterecord()</CODE> - <STRONG>record</STRONG>, <STRONG>field</STRONG>, i1 (' '), i2 (' '), ordered ('y')

<P>
<CODE>updatefields()</CODE> - <STRONG>record</STRONG>, <STRONG>field</STRONG> 

 

<P>
<CODE>deletefirst()</CODE> - <STRONG>record</STRONG>, <STRONG>field</STRONG>, subfield

<P>
<CODE>updatefirst()</CODE> - <STRONG>record</STRONG>, <STRONG>field</STRONG>, subfield, i1,i2


<P>
Methods that accept a <EM>subfield</EM> option also accept specifying it as a supplemental parameter. (Deletefirst
and updatefirst are the only exceptions). Supplemental parameters
append/overwrite the hash values specified in the template.

<P>
<PRE>    $x-&gt;deletemarc($loc852, 'subfield','k');
</PRE>
<P>
<PRE>    my $f260 = {field=&gt;&quot;260&quot;,regex=&gt;&quot;/19../&quot;};
    my @records=$x-&gt;searchmarc($f260,'subfield','c');
    foreach $found (@records) {
        $value = $x-&gt;getvalue($f260,'record',&quot;$found&quot;,'field',&quot;245&quot;);
        print &quot;TITLE: $value\n&quot;;
    }
</PRE>
<P>
<HR>
<H1><A NAME="METHODS">METHODS</A></H1>
<P>
Here is a list of the methods in MARC.pm that are available to you for
reading in, manipulating and outputting MARC data.

<P>
<HR>
<H2><A NAME="new_">new()</A></H2>
<P>
Creates a new MARC object. 

<P>
<PRE>    $x = MARC-&gt;new();
</PRE>
<P>
You can also use the optional <EM>file</EM> and <EM>format</EM> parameters to create and populate the object with data from a file. If a
file is specified it will read in the entire file. If you wish to read in
only portions of the file see <CODE>openmarc(),</CODE>
<CODE>nextmarc(),</CODE> and <CODE>closemarc()</CODE> below. The <EM>format</EM> defaults to <CODE>'usmarc'</CODE> if not specified. It is only used when a <EM>file</EM> is given.

<P>
<PRE>    $x = MARC-&gt;new(&quot;mymarc.dat&quot;,&quot;usmarc&quot;);
    $x = MARC-&gt;new(&quot;mymarcmaker.mkr&quot;,&quot;marcmaker&quot;);
</PRE>
<P>
Creates a new MARC::Rec object.

<P>
<PRE>    $rec=MARC::Rec-&gt;new();
    $rec=MARC::Rec-&gt;new($filehandle,&quot;usmarc&quot;);
</PRE>
<P>
MARC::Rec objects are typically created by reading from a filehandle using
<CODE>nextrec()</CODE> and a proto MARC::Rec object or by directly stuffing
the @{$rec-&gt;{'array'}} array.
    

<P>
<HR>
<H2><A NAME="openmarc_">openmarc()</A></H2>
<P>
Opens a specified file for reading data into a MARC object. If no format is
specified <CODE>openmarc()</CODE> will default to USMARC. The <EM>increment</EM> parameter defines how many records you would like to read from the file. If
no <EM>increment</EM> is defined then the file will just be opened, and no records will be read
in. If <EM>increment</EM> is set to -1 then the entire file will be read in.

<P>
<PRE>    $x = new MARC;
    $x-&gt;openmarc({file=&gt;&quot;mymarc.dat&quot;,'format'=&gt;&quot;usmarc&quot;,
                  increment=&gt;&quot;1&quot;});
    $x-&gt;openmarc({file=&gt;&quot;mymarcmaker.mkr&quot;,'format'=&gt;&quot;marcmaker&quot;,
                  increment=&gt;&quot;5&quot;});
</PRE>
<P>
note: <CODE>openmarc()</CODE> will return the number of records read in. If
the file opens successfully, but no records are read, it returns <CODE>&quot;0 but true&quot;</CODE>. For example:

<P>
<PRE>    $y=$x-&gt;openmarc({file=&gt;&quot;mymarc.dat&quot;,'format'=&gt;&quot;usmarc&quot;,
                     increment=&gt;&quot;5&quot;});
    print &quot;Read in $y records!&quot;;
</PRE>
<P>
When the <EM>MARCMaker</EM> format is specified, the <EM>lineterm</EM> parameter can be used to override the CRLF line-ending default (the format
was originally released for MS-DOS). A <EM>charset</EM> parameter accepts a hash-reference to a user supplied character translation
table. The ``usmarc.txt'' table supplied with the LoC. MARCMaker utility is
used internally as the default. You can use the <STRONG>usmarc_default</STRONG> method to get a hash-reference to it if you only want to modify a couple of
characters. See example below.

<P>
<PRE>    $x-&gt;openmarc({file=&gt;&quot;makrbrkr.mrc&quot;,'format'=&gt;&quot;marcmaker&quot;,
                  increment=&gt;&quot;5&quot;,lineterm=&gt;&quot;\n&quot;,
                  charset=&gt;\%char_hash});
</PRE>
<P>
openmarc inherits some error checking sanity checks from
MARC::Rec::nextrec. These will lead it to return the negative of the number
of records read in if there is a header length error. This behavior can be
suppressed with an option:

<P>
<PRE>    $x-&gt;openmarc({file=&gt;&quot;mymarc.dat&quot;, format=&gt;&quot;usmarc&quot;,
                  increment=&gt; 1, strict =&gt; 0});
</PRE>
<P>
<HR>
<H2><A NAME="nextmarc_">nextmarc()</A></H2>
<P>
Once a file is open <CODE>nextmarc()</CODE> can be used to read in the next
group of records. The increment can be passed to change the number of
records read in if necessary. An increment of -1 will read in the rest of
the file. Specifying the increment will change the value set with
<CODE>openmarc().</CODE> Otherwise, that value is the default.

<P>
<PRE>    $x-&gt;nextmarc();
    $x-&gt;nextmarc(10);
    $x-&gt;nextmarc(-1);
</PRE>
<P>
note: Similar to <CODE>openmarc(),</CODE> <CODE>nextmarc()</CODE> will
return the number of records read in. 

<P>
<PRE>    $y=$x-&gt;nextmarc();
    print &quot;$y more records read in!&quot;;
</PRE>
<P>
<HR>
<H2><A NAME="nextrec_">nextrec()</A></H2>
<P>
MARC:Rec instances can read from a filehandle and produce a new MARC::Rec
instance. If nextrec is passed a string, it will read from that instead.
The string should be formatted according to the {format} field of the
instance.

<P>
Cases where a new instance cannot be created are classified by a status
value:

<P>
<PRE>    my ($newrec,$status) = $rec-&gt;nextrec();
</PRE>
<P>
<CODE>$status</CODE> is undefined if we are at the end of the filehandle.
If the data read from the filehandle cannot be made into a marc record,
<CODE>$status</CODE> will be negative. For example, <CODE>$status</CODE> is
-1 if there is a distinction between recsize and leader definition of
recsize, and -2 if the leader is not numeric.

<P>
An idiom for reading records incrementally with MARC::Recs is:

<P>
<PRE>    my $proto=MARC::Rec-&gt;new($filehandle,$format);
    while (1) {
          my ($rec,$status)=$proto-&gt;nextrec();
          last unless $status;
          die &quot;Bad record, bad, bad record: error $status&quot;
              if $status &lt;0;
          print $rec-&gt;output({$format=&gt;'ascii'});
          # or replace print and output with your own functions/methods.
    }
    close $filehandle or die &quot;File $filehandle is not happy on close\n&quot;;
</PRE>
<P>
If you are getting records from an external source as strings, the idiom
is:

<P>
<PRE>    my $proto=MARC::Rec-&gt;new($filehandle,$format);
    while (1) {
          my $string = get_external_marc();
          last unless $string;
          my ($rec,$status)=$proto-&gt;nextrec($string);
          last unless $status;
          die &quot;Bad record, bad, bad record: error $status&quot;
              if $status &lt;0;
          print $rec-&gt;output({$format=&gt;'ascii'});
          # or replace print and output with your own functions/methods.
    }
</PRE>
<P>
<HR>
<H2><A NAME="closemarc_">closemarc()</A></H2>
<P>
If you are finished reading in records from a file you should close it
immediately.

<P>
<PRE>    $x-&gt;closemarc();
</PRE>
<P>
<HR>
<H2><A NAME="add_map_">add_map()</A></H2>
<P>
<CODE>add_map()</CODE> takes a recnum and a ref to a field in ($tag,
$i1,$i2,a=&gt;``bar'',...) or ($tag, $field) formats and will append to the
various indices that we have hanging off that record. It is intended for
use in creating records de novo and as a component for
<CODE>rebuild_map().</CODE> It carefully does not copy subfield values or
entire fields, maintaining some reference relationships. What this means
for indices created with add_map that you can directly edit subfield values
in $marc-&gt;[recnum]{array} and the index will adjust automatically.
Vice-versa, if you edit subfield values in
$marc-&gt;{recnum}{tag}{subfield_code} the fields in
$marc-&gt;[recnum]{array} will adjust. If you change structural information
in the array with such an index, you must rebuild the part of the index
related to the current tag (and possibly the old tag if you change the
tag).

<P>
<PRE>   use MARC 1.02;
   while (&lt;&gt;) {
        chomp;
        my ($author,$title) = split(/\t/);
        my $rnum = $x-&gt;createrecord({leader=&gt;
                                       &quot;00000nmm  2200000 a 4500&quot;});
</PRE>
<P>
<PRE>        my @auth = (100, ' ', ' ', a=&gt;$author);
        my @title = (245, ' ', ' ', a=&gt;$title);
        push @{$x-&gt;[$rnum]{array}}, \@auth;
        $x-&gt;add_map($rnum,\@auth);
        push @{$x-&gt;[$rnum]{array}}, \@title;
        $x-&gt;add_map($rnum,\@title);
   }
</PRE>
<P>
MARC::Rec::add_map($rfield) does not need the record specification and has
the same effect as add_map.

<P>
<HR>
<H2><A NAME="rebuild_map">rebuild_map</A></H2>
<P>
rebuild_map takes a recnum and a tag and will synchronize the index with
the array elements of the marc record at the recnum with that tag.

<P>
<PRE>      #Gonna change all 099's to 092's since this is a music collection.
      grep {$-&gt;[0] =~s/099/092} @{$x-&gt;[$recnum]{array}};
      
      #Oops, now the index is out of date on the 099's...
      $x-&gt;rebuild_map($recnum,099);
      #... and the 092's since we now have new ones.
      $x-&gt;rebuild_map($recnum,092);
      #All fixed.
</PRE>
<P>
MARC::Rec::rebuild_map($tag) does not need the record number and has the
same effect as rebuild_map.

<P>
<HR>
<H2><A NAME="rebuild_map_all">rebuild_map_all</A></H2>
<P>
rebuild_map takes a recnum and will synchronize the index with the array
elements of the marc record at the recnum.

<P>
MARC::Rec::rebuild_map_all() does not need the record number and has the
same effect as rebuild_map_all.

<P>
<HR>
<H2><A NAME="getfields">getfields</A></H2>
<P>
getfields takes a template and returns an array of fieldrefs from the
record number implied by that template. The fields referred are fields from
the $marc-&gt;[$recnum]{array} group. The fields are all fields from the
first one with the tag from the template to the last with that tag. Some
marc records (e.g. cjk) may have fields with other tags mixed in.
Consecutive calls to updatefields with a different tag and the same record
are probably a bad idea unless you have assurance that fields with the same
tag are always together.

<P>
MARC::Rec::getfields is identical to getfields, but ignores any record
specification in the template.

<P>
<HR>
<H2><A NAME="marc_count_">marc_count()</A></H2>
<P>
Returns the total number of records in a MARC object. This method was
previously named <STRONG>length()</STRONG>, but that conflicts with the Perl built-in of the same name. Use the new
name, the old one is deprecated and will disappear shortly.

<P>
<PRE>    $length=$x-&gt;marc_count();
</PRE>
<P>
<HR>
<H2><A NAME="getfirstvalue_">getfirstvalue()</A></H2>
<P>
getfirstvalue will return the first value of a field or subfield or
indicator or i12 in a particular record found in the MARC object. It does
not depend on the index being up to date.

<P>
MARC::Rec::getfirstvalue is identical to getfirstvalue, but ignores any
record specification in the template.

<P>
<HR>
<H2><A NAME="getvalue_">getvalue()</A></H2>
<P>
This method will retrieve MARC field data from a specific record in the
MARC object. <CODE>getvalue()</CODE> takes four parameters: <EM>record</EM>, <EM>field</EM>, <EM>subfield</EM>, and <EM>delimiter</EM>. Since a single MARC record could contain several of the fields or
subfields the results are returned to you as an array. If you only pass <EM>record</EM> and <EM>field</EM> you will be returned the entire field without subfield delimiters.
Optionally you can use <EM>delimiter</EM> to specify what character to use for the delimiter, and you will also get
the subfield delimiters. If you also specify <EM>subfield</EM> your results will be limited to just the contents of that subfield.
Repeated subfield occurances will end up in separate array elements in the
order in which they were read in. The <EM>subfield</EM> designations <CODE>'i1', 'i2' and 'i12'</CODE> can be used to get <CODE>indicator(s).</CODE>

<P>
<PRE>        #get the 650 field(s)
    @results = $x-&gt;getvalue({record=&gt;'1',field=&gt;'650'}); 
</PRE>
<P>
<PRE>        #get the 650 field(s) with subfield delimiters (ie. |x |v etc)
    @results = $x-&gt;getvalue({record=&gt;'1',field=&gt;'650',delimiter=&gt;'|'});
</PRE>
<P>
<PRE>        #get all of the subfield u's from the 856 field
    @results = $x-&gt;getvalue({record=&gt;'12',field=&gt;'856',subfield=&gt;'u'});
</PRE>
<P>
MARC::Rec::getvalue($template) is identical to getvalue, but ignores any
record specification.

<P>
<HR>
<H2><A NAME="unpack_ldr_record_">unpack_ldr($record)</A></H2>
<P>
Returns a ref to a hash version of the record'th LDR. Installs the ref in
<CODE>$marc</CODE> as $marc-&gt;[$record]{unp_ldr}

<P>
<PRE>    my $rldr = $x-&gt;unpack_ldr(1);
    print &quot;Desc is $rldr{Desc}&quot;;
    my ($m040) = $x-&gt;getvalues({record=&gt;'1',field=&gt;'040'});
    print &quot;First record is LC, let's leave it alone&quot; 
          if $rldr-&gt;{'Desc'} eq 'a' &amp;&amp; $m040=~/DLC\s*\c_c\s*DLC/; 
</PRE>
<P>
The hash version contains the following information:

<P>
<PRE>        Key             000-Pos length  Function [standard value]
        ---             ------- ------  --------
        rec_len         00-04      5    Logical Record Length
        RecStat         05         1    Record Status
        Type            06         1    Type of Record
        BLvl            07         1    Bibliographic Level
        Ctrl            08         1
        Undefldr        09-11      3    [x22]
        base_addr       12-16      5    Base Address of Data
        ELvl            17         1    Encoding Level
        Desc            18         1    Descriptive Cataloging Form
        ln_rec          19         1    Linked-Record Code
        len_len_field   20         1    Length &quot;length of field&quot; [4]
        len_start_char  21         1    Length &quot;start char pos&quot; [5]
        len_impl        22         1    Length &quot;implementation dep&quot; [0]
        Undef2ldr       23         1    [0]
</PRE>
<P>
MARC::Rec::unpack_ldr() is identical to unpack_ldr, but does not need the
record number.

<P>
<HR>
<H2><A NAME="get_hash_ldr_record_">get_hash_ldr($record)</A></H2>
<P>
Takes a record number. Returns a ref to the cached version of the hash ldr
if it exists. Does this *without* overwriting the hash ldr. Allows external
code to safely manipulate hash versions of the ldr.

<P>
<PRE>     my $rhldr = $marc-&gt;get_hash_ldr($record);
     return undef unless $rhldr;
     $rhldr-&gt;{'Desc'} =~ s/a/b/;
     $ldr = $x-&gt;pack_ldr($record);
</PRE>
<P>
MARC::Rec::get_hash_ldr() is identical to get_hash_ldr, but does not need
the record number.

<P>
<HR>
<H2><A NAME="pack_ldr_record_">pack_ldr($record)</A></H2>
<P>
Takes a record number. Updates the appropriate ldr. 

<P>
<PRE>     $marc-&gt;[$record]{'unp_ldr'}{'Desc'} =~ s/a/b/;
     my $ldr = $x-&gt;pack_ldr($record);
     return undef unless $ldr;
</PRE>
<P>
MARC::Rec::pack_ldr() is identical to pack_ldr, but does not need the
record number.

<P>
<HR>
<H2><A NAME="bib_format_record_">bib_format($record)</A></H2>
<P>
Takes a record number. Returns the ``format'' used in determining the
meanings of the fixed fields in 008. Will force update of the ldr based on
any existing hash version.

<P>
<PRE>      foreach $record (1..$#$x) {
            next if $x-&gt;bib_format($record) eq 'SERIALS';
                # serials are hard
            do_something($x-&gt;[record]);
      }
</PRE>
<P>
MARC::Rec::bib_format() is identical to bib_format, but does not need the
record number.

<P>
<HR>
<H2><A NAME="unpack_008_record_">unpack_008($record)</A></H2>
<P>
Returns a ref to hash version of the 008 field, based on the field's value.
Installs the ref as $marc-&gt;[$record]{unp_008}

<P>
<PRE>      foreach $record (1..$#$x) {
            my $rff = $x-&gt;unpack_008($record);
            print &quot;Record $record: Y2K problem possible&quot;
                if ($rff-&gt;{'Date1'}=~/00/ or $rff-&gt;{'Date2'}=~/00/);
      }
</PRE>
<P>
MARC::Rec::unpack_008() is identical to unpack_008, but does not need the
record number.

<P>
<HR>
<H2><A NAME="get_hash_008_record_">get_hash_008($record)</A></H2>
<P>
Takes a record number. Returns a ref to the cached version of the hash 008
if it exists. Does this *without* overwriting the hash 008. Allows external
code to safely manipulate hash versions of the 008.

<P>
<PRE>     my $rh008 = $marc-&gt;get_hash_008($record);
     return undef unless $rh008;
     $rh008-&gt;{'Date1'} =~ s/00/01/;
     my $m008 = $x-&gt;pack_008($record);
     return undef unless $m008;
</PRE>
<P>
MARC::Rec::get_hash_008() is identical to get_hash_008, but does not need
the record number.

<P>
<HR>
<H2><A NAME="pack_008_record_">pack_008($record)</A></H2>
<P>
Takes a record number and updates the appropriate 008. Will force update of
the ldr based on any existing hash version. Updates the map for 008.

<P>
<PRE>      foreach $record (1..$#$x) {
            my $rff = $x-&gt;unpack_008($record);
            $rff-&gt;{'Date1'}='2000';
            print &quot;Record:$record Y2K problem created\n&quot;;
            $x-&gt;pack_008($record);
            # New value is in the 008 field of $record'th marc
      }
</PRE>
<P>
MARC::Rec::pack_008() is identical to pack_008, but does not need the
record number.

<P>
<HR>
<H2><A NAME="deletefirst_">deletefirst()</A></H2>
<P>
<CODE>deletefirst()</CODE> takes a template. It deletes the field data for
a first match, using the template and leaves the rest alone. 

<P>
For example, assume that we have a marc file whose second record looks
like:

<P>
<PRE>    =008  960221s1955\\\\dcuabcdjdbkoqu001\0dspa\d
    =020  \\$a0777000008 :$c{24}35.99
    =020  \\$a0777000008 :$c{curren}35.99
    =040  \\$aViArRB$cViArRB
    =100  2 $aDeer-Doe, Jane,$d1957-
</PRE>
<P>
Assume we have placed this in a MARC object x. Then we can delete an entire
field of the second record thus:

<P>
<PRE>    my $loc100 = {record=&gt;2,field=&gt;100,rebuild_map=&gt;1};
    $x-&gt;deletefirst($loc100);
</PRE>
<P>
The second record now looks like:

<P>
<PRE>    =008  960221s1955\\\\dcuabcdjdbkoqu001\0dspa\d
    =020  \\$a0777000008 :$c{24}35.99
    =020  \\$a0777000008 :$c{curren}35.99
    =040  \\$aViArRB$cViArRB
</PRE>
<P>
If the template has a subfield element it deletes based on the subfield
information in the template.

<P>
<PRE>    $x-&gt;deletefirst({record=&gt;2,field=&gt;020,subfield=&gt;'c',rebuild_map=&gt;1};
</PRE>
<P>
<PRE>    =008  960221s1955\\\\dcuabcdjdbkoqu001\0dspa\d
    =020  \\$a0777000008 :
    =020  \\$a0777000008 :$c{curren}35.99
    =040  \\$aViArRB$cViArRB
</PRE>
<P>
<PRE> If the last subfield of a field is deleted,
deletefirst() also deletes the field.
</PRE>
<P>
<PRE>    $x-&gt;deletefirst({record=&gt;2,field=&gt;020,subfield=&gt;'a',rebuild_map=&gt;1};
</PRE>
<P>
<PRE>    =008  960221s1955\\\\dcuabcdjdbkoqu001\0dspa\d
    =020  \\$a0777000008 :$c{curren}35.99
    =040  \\$aViArRB$cViArRB
</PRE>
<P>
<PRE>  It complains about attempts to
delete indicators. 
</PRE>
<P>
<PRE>    $x-&gt;deletefirst({record=&gt;2,field=&gt;020,subfield=&gt;'i1',rebuild_map=&gt;1};
    OR
    $x-&gt;deletefirst({record=&gt;2,field=&gt;020,i1=&gt;1,rebuild_map=&gt;1};
</PRE>
<P>
Produces a warning and leaves the record untouched.

<P>
<PRE> If there is no match, it does nothing.
</PRE>
<P>
<PRE>    $x-&gt;deletefirst({record=&gt;2,field=&gt;020,subfield=&gt;'x',rebuild_map=&gt;1};
</PRE>
<P>
<PRE>    =008  960221s1955\\\\dcuabcdjdbkoqu001\0dspa\d
    =020  \\$a0777000008 :$c{curren}35.99
    =040  \\$aViArRB$cViArRB
</PRE>
<P>
<PRE> Deletefirst also rebuilds the map if the template asks for that
$do_rebuild_map. Deletefirst returns the number of matches deleted
(that would be 0 or 1), or undef if it feels grumpy (i.e. carps).
</PRE>
<P>
MARC::Rec::deletefirst($template) is identical to deletefirst, but ignores
any record number specified by $template.

<P>
Most use of deletefirst is expected to be by Tie::MARC.

<P>
<HR>
<H2><A NAME="deletemarc_">deletemarc()</A></H2>
<P>
This method will allow you to remove a specific record, fields or subfields
from a MARC object. Accepted parameters include: <EM>record</EM>, <EM>field</EM> and <EM>subfield</EM>. Note: you can use the .. operator to delete a range of records.
<CODE>deletemarc()</CODE> will return the number of items deleted (be they
records, fields or subfields). The <EM>record</EM> parameter is optional. It defaults to all user records [1..$#marc] if not
specified.

<P>
<PRE>        #delete all the records in the object
    $x-&gt;deletemarc();
</PRE>
<P>
<PRE>        #delete records 1-5 and 7 
    $x-&gt;deletemarc({record=&gt;[1..5,7]});
</PRE>
<P>
<PRE>        #delete all of the 650 fields from all of the records
    $x-&gt;deletemarc({field=&gt;'650'});
</PRE>
<P>
<PRE>        #delete the 110 field in record 2
    $x-&gt;deletemarc({record=&gt;'2',field=&gt;'110'});
</PRE>
<P>
<PRE>        #delete all of the subfield h's in the 245 fields
    $x-&gt;deletemarc({field=&gt;'245',subfield=&gt;'h'});
</PRE>
<P>
<HR>
<H2><A NAME="updatefirst_">updatefirst()</A></H2>
<P>
<CODE>updatefirst()</CODE> takes a template, and an array from
$marc-&gt;[recnum]{array}. It replaces/creates the field data for a first
match, using the template and the array, and leaves the rest alone. If the
template has a subfield element, (this includes indicators) it ignores all
other information in the array and only updates/creates based on the
subfield information in the array. If the template has no subfield
information then indicators are left untouched unless a new field needs to
be created, in which case they are left blank.

<P>
MARC::Rec::updatefirst($template) is identical to deletefirst, but ignores
any record number specified by $template.

<P>
Most use of <CODE>updatefirst()</CODE> is expected to be from Tie::MARC. It
does not currently provide a useful return value.

<P>
<HR>
<H2><A NAME="updatefields_">updatefields()</A></H2>
<P>
<CODE>updatefields()</CODE> takes a template which specifies recnum, a
<CODE>$do_rebuild_map</CODE> and a field (needs the field in case
$rafields-&gt;[0] is empty). It also takes a ref to an array of fieldrefs
formatted like the output of <CODE>getfields(),</CODE> and replaces/creates
the field data. It assumes that it should replace the fields with the first
tag in the fieldrefs. It calls <CODE>rebuild_map()</CODE> if
$do_rebuild_map.

<P>
<PRE>    #Let's kill the *last* 500 field.
    my $loc500 = {record=&gt;1,field=&gt;500,rebuild_map=&gt;1};
    my @rfields = $x-&gt;getfields($loc500);
    pop @rfields;
    $x-&gt;updatefields($loc500,\@rfields);
</PRE>
<P>
<HR>
<H2><A NAME="getmatch_">getmatch()</A></H2>
<P>
<CODE>getmatch()</CODE> takes a subfield code (can be an indicator) and a
fieldref. Returns 0 or a ref to the value to be updated. #Let's update the
value of i2 for the *last* 500 my <CODE>$loc500</CODE> =
{record=&gt;1,field=&gt;500,rebuild_map=&gt;1}; my <CODE>@rfields</CODE> =
$x-&gt;getfields($loc500); my <CODE>$rvictim</CODE> = pop @rfields; my
<CODE>$rval</CODE> = <CODE>getmatch('i2',$rvictim);</CODE>
<CODE>$$rval</CODE> = ``4'' if $rval;

<P>
MARC::Rec::getmatch($subf,$rfield) is identical to getmatch.

<P>
<HR>
<H2><A NAME="insertpos_">insertpos()</A></H2>
<P>
<CODE>insertpos()</CODE> takes a subfield code (can not be an indicator), a
value, and a fieldref. Updates the fieldref with the first place that the
fieldref can match. Assumes there is no exact subfield match in $fieldref.

<P>
<PRE>    #Let's update the value of subfield 'a' for the *last* 500
    my $value = &quot;new info&quot;;
    my $loc500 = {record=&gt;1,field=&gt;500,rebuild_map=&gt;1};
    my @rfields = $x-&gt;getfields($loc500);
    my $rvictim = pop @rfields;
    my $rval = getmatch('a',$rvictim);
    if ($rval) {
        $$rval = $value ;
    } else {
        $x-&gt;insertpos('a',$value,$rvictim);
    }
</PRE>
<P>
MARC::Rec::insertpos($subf,$value,$rfield) is identical to insertpos;

<P>
<HR>
<H2><A NAME="selectmarc_">selectmarc()</A></H2>
<P>
This method will select specific records from a MARC object and delete the
rest. You can specify both individual records and ranges of records in the
same way as <CODE>deletemarc().</CODE> <CODE>selectmarc()</CODE> will also
return the number of records deleted. 

<P>
<PRE>    $x-&gt;selectmarc(['3']);
    $y=$x-&gt;selectmarc(['4','21-50','60']);
    print &quot;$y records selected!&quot;;
</PRE>
<P>
<HR>
<H2><A NAME="searchmarc_">searchmarc()</A></H2>
<P>
This method will allow you to search through a MARC object, and retrieve
record numbers for records that matched your criteria. You can search for:
1) records that contain a particular field, or field and subfield ; 2)
records that have fields or subfields that match a regular expression ; 3)
and records that have fields or subfields that <STRONG>do not</STRONG> match a regular expression. The record numbers are returned to you in an
array which you can then use with <CODE>deletemarc(),</CODE>
<CODE>selectmarc()</CODE> and <CODE>output()</CODE> if you want.

<UL>
<LI>
<P>
1) Field/Subfield Presence:

<P>
<PRE>    @records=$x-&gt;searchmarc({field=&gt;&quot;245&quot;});
    @records=$x-&gt;searchmarc({field=&gt;&quot;245&quot;,subfield=&gt;&quot;a&quot;});
</PRE>
<LI>
<P>
2) Field/Subfield Match:

<P>
<PRE>    @records=$x-&gt;searchmarc({field=&gt;&quot;245&quot;,
                             regex=&gt;&quot;/huckleberry/i&quot;});
    @records=$x-&gt;searchmarc({field=&gt;&quot;260&quot;,subfield=&gt;&quot;c&quot;,
                             regex=&gt;&quot;/19../&quot;});
</PRE>
<LI>
<P>
3) Field/Subfield NotMatch:

<P>
<PRE>    @records=$x-&gt;searchmarc({field=&gt;&quot;245&quot;,
                             notregex=&gt;&quot;/huckleberry/i&quot;});
    @records=$x-&gt;searchmarc({field=&gt;&quot;260&quot;,
                             subfield=&gt;&quot;c&quot;,notregex=&gt;&quot;/19../&quot;});
</PRE>
</UL>
<P>
<HR>
<H2><A NAME="createrecord_">createrecord()</A></H2>
<P>
You can use this method to initialize a new record. It only takes one
optional parameter, <EM>leader</EM> which sets the 24 characters in the record leader: see <A
HREF="http://lcweb.loc.gov/marc/bibliographic/ecbdhome.html">http://lcweb.loc.gov/marc/bibliographic/ecbdhome.html</A>
for more details on the leader. Note: you do not need to pass character
positions 00-04 or 12-16 since these are calculated by MARC.pm if
outputting to MARC you can assign 0 to each position. If no leader is
passed a default USMARC leader will be created of ``00000nam 2200000 a
4500''. <CODE>createrecord()</CODE> will return the record number for the
record that was created, which you will need to use later when adding
fields with <CODE>addfield().</CODE> Createrecord now makes the new record
an instance of an appropriate MARC::Rec subclass. 

<P>
<PRE>    use MARC;
    my $x = new MARC;
    $record_number = $x-&gt;createrecord();
    $record_number = $x-&gt;createrecord({leader=&gt;
                                       &quot;00000nmm  2200000 a 4500&quot;});
</PRE>
<P>
MARC::Rec::createrecord($leader) returns an instance of a suitable subclass
of MARC::Rec.

<P>
<HR>
<H2><A NAME="getupdate_">getupdate()</A></H2>
<P>
The <STRONG>getupdate()</STRONG> method returns an array that contains the contents of a field in a defined
order that permits restoring the field after deleting it. This permits
changing only individual subfields while keeping other data intact. If a
field is repeated in the record, the resulting array separates the field
information with an element containing ``\036'' - the internal field
separator which can never occur in real MARC data parameters. A
non-existing field returns <CODE>undef</CODE>. An example will make the structure clearer. The next two MARC fields
(shown in ASCII) will be described in the following array:

<P>
<PRE>                246  30  $aPhoto archive
                246  3   $aAssociated Press photo archive
</PRE>
<P>
<PRE>    my $update246 = {field=&gt;'246',record=&gt;2,ordered=&gt;'y'};
        # next two statements are equivalent
    my @u246 = $x-&gt;getupdate($update246);
        # or
    my @u246 = ('i1','3','i2','0',
                'a','Photo archive',&quot;\036&quot;,
                'i1','3','i2',' ',
                'a','Associated Press photo archive',&quot;\036&quot;);
        
After making any desired modifications to the data, the existing field can be replaced using the following sequence (for non-repeating fields):
</PRE>
<P>
<PRE>    $x-&gt;deletemarc($update246));
    my @records = ();
    foreach my $y1 (@u246) {
        last if ($y1 eq &quot;\036&quot;);
        push @records, $y1;
    }
    $x-&gt;addfield($update246, @records);
</PRE>
<P>
<HR>
<H2><A NAME="updaterecord_">updaterecord()</A></H2>
<P>
The <CODE>updaterecord()</CODE> method is a more complete version of the
preceding sequence with error checking and the ability to split the update
array into multiple <CODE>addfield()</CODE> commands when given repeating
fields. It takes an array of key/value pairs, formatted like the output of
<CODE>getupdate(),</CODE> and replaces/creates the field data. For repeated
tags, a ``\036'' element is used to delimit data into separate
<CODE>addfield()</CODE> commands. It returns the number of successful
<CODE>addfield()</CODE> commands or <CODE>undef</CODE> on failure.

<P>
<PRE>    $repeats = $x-&gt;updaterecord($update246, @u246);     # same as above
</PRE>
<P>
<HR>
<H2><A NAME="addfield_">addfield()</A></H2>
<P>
This method will allow you to addfields to a specified record. The syntax
may look confusing at first, but once you understand it you will be able to
add fields to records that you have read in, or to records that you have
created with <CODE>createrecord().</CODE> <CODE>addfield()</CODE> takes six
parameters: <EM>record</EM> which indicates the record number to add the field to, <EM>field</EM> which indicates the field you wish to create (ie. 245), <EM>i1</EM> which holds one character for the first indicator, <EM>i2</EM> which holds one character for the second indicator, and <EM>value</EM> which holds the subfield data that you wish to add to the field.
<CODE>addfield()</CODE> will automatically try to insert your new field in
tag order (ie. a 500 field before a 520 field), however you can turn this
off if you set <EM>ordered</EM> to ``no'' which will add the field to the end. Here are some examples:

<P>
<PRE>    $y = $x-&gt;createrecord(); # $y will store the record number created
</PRE>
<P>
<PRE>    $x-&gt;addfield({record=&gt;&quot;$y&quot;, field=&gt;&quot;100&quot;, i1=&gt;&quot;1&quot;, i2=&gt;&quot;0&quot;,
                  value=&gt; [a=&gt;&quot;Twain, Mark, &quot;, d=&gt;&quot;1835-1910.&quot;]});
</PRE>
<P>
<PRE>    $x-&gt;addfield({record=&gt;&quot;$y&quot;, field=&gt;&quot;245&quot;,
                  i1=&gt;&quot;1&quot;, i2=&gt;&quot;4&quot;, value=&gt;
                 [a=&gt;&quot;The adventures of Huckleberry Finn /&quot;,
                  c=&gt;&quot;Mark Twain ; illustrated by E.W. Kemble.&quot;]});
</PRE>
<P>
This example initialized a new record, and added a 100 field and a 245
field. For some more creative uses of the <CODE>addfield()</CODE> function
take a look at the <EM>EXAMPLES</EM> section. The <EM>value</EM> parameters, including <EM>i1</EM> and <EM>i2</EM>, can be specified using a separate array. This permits restoring
<CODE>field(s)</CODE> from the array returned by the <STRONG>getupdate()</STRONG> method - either as-is or with modifications. The <EM>i1</EM> and <EM>i2</EM> key/value pairs must be first and in that order if included.

<P>
<PRE>        # same as &quot;100&quot; example above
    my @v100 = 'i1','1','i2',&quot;0&quot;,'a',&quot;Twain, Mark, &quot;,
               'd',&quot;1835-1910.&quot;;
    $x-&gt;addfield({record=&gt;&quot;$y&quot;, field=&gt;&quot;100&quot;}, @v100);
</PRE>
<P>
<HR>
<H2><A NAME="add_005s_">add_005s()</A></H2>
<P>
Add_005s takes a specification of records (defaults to everything) and
updates the indicated records with updated 005 fields (date of last
transaction).

<P>
<HR>
<H2><A NAME="output_">output()</A></H2>
<P>
Output is a multi-functional method for creating formatted output from a
MARC object. There are three parameters <EM>file</EM>, <EM>format</EM>, <EM>records</EM>. If <EM>file</EM> is specified the output will be directed to that file. It is important to
specify with &gt; and &gt;&gt; whether you want to create or append the file! If no <EM>file</EM> is specified then the results of the output will be returned to a variable
(both variations are listed below). 

<P>
The MARC standard includes a control field (005) that records the date of
last automatic processing. This is implemented as a side-effect of
<CODE>output()</CODE> to a file or if explicitly requested via a add_005s
field of the template. The current time is stamped on the records indicated
by the template.

<P>
Valid <EM>format</EM> values currently include usmarc, marcmaker, ascii, html, urls, and isbd.
The optional <EM>records</EM> parameter allows you to pass an array of record numbers which you wish to
output. You must pass the array as a reference, hence the forward-slash in
\@records below. If you do not include <EM>records</EM> the output will default to all the records in the object. 

<P>
The <EM>lineterm</EM> parameter can be used to override the line-ending default for any of the
formats. <EM>MARCMaker</EM> defaults to CRLF (the format was originally released for MS-DOS). The
others use '\n' as the default.

<P>
With the <EM>MARCMaker</EM> format, a <EM>charset</EM> parameter accepts a hash-reference to a user supplied character translation
table. The ``ustext.txt'' table supplied with the LoC. MARCBreaker utility
is used internally as the default. You can use the <STRONG>ustext_default</STRONG> method to get a hash-reference to it if you only want to modify a couple of
characters. See example below.

<P>
The <EM>MARCMaker</EM> Specification requires that long lines be split to less than 80 columns.
While that behavior is the default, the <EM>nolinebreak</EM>
parameter can override it and the resulting output will be much like the
<EM>ascii</EM> format.

<P>
MARC::Rec::output($template) is the same as output except that ignores
record <CODE>number(s)</CODE> and only outputs its caller. (E.g., with
<CODE>$format</CODE> eq 'urls' it does not output html header and footer
information.)

<UL>
<LI>
<P>
MARC

<P>
<PRE>    $x-&gt;output({file=&gt;&quot;&gt;mymarc.dat&quot;,'format'=&gt;&quot;usmarc&quot;});
    $x-&gt;output({file=&gt;&quot;&gt;mymarc.dat&quot;,'format'=&gt;&quot;usmarc&quot;,
                records=&gt;\@records});
    $y=$x-&gt;output({'format'=&gt;&quot;usmarc&quot;}); #put the output into $y
</PRE>
<LI>
<P>
MARCMaker

<P>
<PRE>    $x-&gt;output({file=&gt;&quot;&gt;mymarcmaker.mkr&quot;,'format'=&gt;&quot;marcmaker&quot;});
    $x-&gt;output({file=&gt;&quot;&gt;mymarcmaker.mkr&quot;,'format'=&gt;&quot;marcmaker&quot;,
                records=&gt;\@records});
    $y=$x-&gt;output({'format'=&gt;&quot;marcmaker&quot;}); #put the output into $y
</PRE>
<P>
<PRE>    $x-&gt;output({file=&gt;&quot;brkrtest.mkr&quot;,'format'=&gt;&quot;marcmaker&quot;,
                nolinebreak=&gt;&quot;1&quot;, lineterm=&gt;&quot;\n&quot;,
                charset=&gt;\%char_hash});
</PRE>
<LI>
<P>
ASCII

<P>
<PRE>    $x-&gt;output({file=&gt;&quot;&gt;myascii.txt&quot;,'format'=&gt;&quot;ascii&quot;});
    $x-&gt;output({file=&gt;&quot;&gt;myascii.txt&quot;,'format'=&gt;&quot;ascii&quot;,
                records=&gt;\@records});
    $y=$x-&gt;output({'format'=&gt;&quot;ascii&quot;}); #put the output into $y
</PRE>
<LI>
<P>
HTML

<P>
The HTML output method has some additional parameters. <EM>fields</EM> which if set to ``all'' will output all of the fields. Or you can pass the
tag number and a label that you want to use for that tag. This will result
in HTML output that only contains the specified tags, and will use the
label in place of the MARC code.

<P>
<PRE>    $x-&gt;output({file=&gt;&quot;&gt;myhtml.html&quot;,'format'=&gt;&quot;html&quot;,
                fields=&gt;&quot;all&quot;});
</PRE>
<P>
<PRE>        #this will only output the 100 and 245 fields, with the 
        #labels &quot;Title: &quot; and &quot;Author: &quot;
    $x-&gt;output({file=&gt;&quot;&gt;myhtml.html&quot;,'format'=&gt;&quot;html&quot;,
                245=&gt;&quot;Title: &quot;,100=&gt;&quot;Author: &quot;});    
</PRE>
<P>
<PRE>    $y=$x-&gt;output({'format'=&gt;&quot;html&quot;});
</PRE>
<P>
If you want to build the HTML file in stages, there are four other <EM>format</EM> values available to you: 1) ``html_header'', 2) ``html_start'', 3)
``html_body'', and 4) ``html_footer''. Be careful to use the &gt;&gt;
append when adding to a file though!

<P>
<PRE>    $x-&gt;output({file=&gt;&quot;&gt;myhtml.html&quot;,
                'format'=&gt;&quot;html_header&quot;}); # Content-type
    $x-&gt;output({file=&gt;&quot;&gt;&gt;myhtml.html&quot;,
                'format'=&gt;&quot;html_start&quot;});  # &lt;BODY&gt;
    $x-&gt;output({file=&gt;&quot;&gt;&gt;myhtml.html&quot;,
                'format'=&gt;&quot;html_body&quot;,fields=&gt;&quot;all&quot;});
    $x-&gt;output({file=&gt;&quot;&gt;&gt;myhtml.html&quot;,
                'format'=&gt;&quot;html_footer&quot;});
</PRE>
<LI>
<P>
URLS

<P>
<PRE>    $x-&gt;output({file=&gt;&quot;urls.html&quot;,'format'=&gt;&quot;urls&quot;});
    $y=$x-&gt;output({'format'=&gt;&quot;urls&quot;});
</PRE>
<LI>
<P>
ISBD

<P>
An experimental output format that attempts to mimic the ISBD.

<P>
<PRE>    $x-&gt;output({file=&gt;&quot;isbd.txt&quot;,'format'=&gt;&quot;isbd&quot;});
    $y=$x-&gt;output({'format'=&gt;&quot;isbd&quot;});
</PRE>
<LI>
<P>
XML

<P>
Round-trip conversion between MARC and XML is handled by the subclass
MARC::XML. MARC::XML is available for download from the CPAN.

</UL>
<P>
<HR>
<H2><A NAME="usmarc_default_">usmarc_default()</A></H2>
<P>
This method returns a hash reference to a translation table between
mnemonics delimited by curly braces and single-byte character codes in the
MARC record. Multi-byte characters are not currently supported. The hash
has keys of the form '{esc}' and values of the form <CODE>chr(0x1b).</CODE>
It is used during MARCMaker input.

<P>
<PRE>    my %inc = %{$x-&gt;usmarc_default()};
    printf &quot;dollar = %s\n&quot;, $inc{'dollar'};     # prints '$'
    $inc{'yen'} = 'Y';
    $x-&gt;openmarc({file=&gt;&quot;makrbrkr.mrc&quot;,'format'=&gt;&quot;marcmaker&quot;,
                  charset=&gt;\%inc});
</PRE>
<P>
MARC::Rec::usmarc_default is identical to usmarc_default;

<P>
<HR>
<H2><A NAME="ustext_default_">ustext_default()</A></H2>
<P>
This method returns a hash reference to a translation table between
single-byte character codes and mnemonics delimited by curly braces.
Multi-byte characters are not currently supported. The hash has keys of the
form <CODE>chr(0x1b)</CODE> and values of the form '{esc}'. It is used
during MARCMaker output.

<P>
<PRE>    my %outc = %{$x-&gt;ustext_default()};
    printf &quot;dollar = %s\n&quot;, $outc{'$'}; # prints '{dollar}'
    $outc{'$'} = '{uscash}';
    printf &quot;dollar = %s\n&quot;, $outc{'$'}; # prints '{uscash}'
    $y = $x-&gt;output({'format'=&gt;&quot;marcmaker&quot;, charset=&gt;\%outc});
</PRE>
<P>
MARC::Rec::ustext_default is identical to ustext_default;

<P>
<HR>
<H2><A NAME="as_string_">as_string()</A></H2>
<P>
<CODE>As_string()</CODE> takes no parameters and returns a (Unix) newline
separated version of the record.

<P>
<PRE>  Format is: $tag&lt;SPACE&gt;$i1$i2&lt;SPACE&gt;$subfields
  where $subfields are separated by &quot;\c_&quot; binary subfield indicators.
  Tag 000 is ldr.
</PRE>
<P>
Subclasses may need to override this format. If so, they should override
from_string.

<P>
<HR>
<H2><A NAME="from_string_">from_string()</A></H2>
<P>
<CODE>From_string()</CODE> takes a string parameter and updates the calling
record's {array} information. It assumes the string is formatted like the
output of <CODE>as_string().</CODE> 

<P>
<HR>
<H1><A NAME="EXAMPLES">EXAMPLES</A></H1>
<P>
Here are a few examples to fire your imagination.

<UL>
<LI>
<P>
This example will read in the complete contents of a MARC file called
``mymarc.dat'' and then output it as a MARCMaker file called ``mymkr.mkr''.

<P>
<PRE>    #!/usr/bin/perl
    use MARC;
    $x = MARC-&gt;new(&quot;mymarc.dat&quot;,&quot;marcmaker&quot;);
    $x-&gt;output({file=&gt;&quot;mymkr.mkr&quot;,'format'=&gt;&quot;marcmaker&quot;);
</PRE>
<LI>
<P>
The MARC object occupies a fair number of working memory, and you may want
to do conversions on very large files. In this case you will want to use
the <CODE>openmarc(),</CODE> <CODE>nextmarc(),</CODE>
<CODE>deletemarc(),</CODE> and <CODE>closemarc()</CODE> methods to read in
portions of the MARC file, do something with the <CODE>record(s),</CODE>
remove them from the object, and then read in the next
<CODE>record(s).</CODE> This example will read in one record at a time from
a MARC file called ``mymarc.dat'' and convert it to a MARC Maker file
called ``myfile.mkr''.

<P>
<PRE>    #!/usr/bin/perl
    use MARC;
    $x = new MARC;
    $x-&gt;openmarc({file=&gt;&quot;mymarc.dat&quot;,'format'=&gt;&quot;usmarc&quot;});
    while ($x-&gt;nextmarc(1)) {
        $x-&gt;output({file=&gt;&quot;&gt;&gt;myfile.mkr&quot;,'format'=&gt;&quot;marcmaker&quot;});
        $x-&gt;deletemarc(); #empty the object for reading in another
    }        
</PRE>
<LI>
<P>
Perhaps you have a tab delimited text file of data for online journals you
have access to from Dow Jones Interactive, and you would like to create a
batch of MARC records to load into your catalog. In this case you can use
<CODE>createrecord(),</CODE> <CODE>addfield()</CODE> and
<CODE>output()</CODE> to create records as you read in your delimited file.
When you are done, you then output to a file in USMARC.

<P>
<PRE>    #!/usr/bin/perl
    use MARC;
    $x = new MARC;
    open (INPUT_FILE, &quot;delimited_file&quot;);
    while ($line=&lt;INPUT_FILE&gt;) {
        ($journaltitle,$issn) = split /\t/,$line;
        $num=$x-&gt;createrecord();
        $x-&gt;addfield({record=&gt;$num, 
                      field=&gt;&quot;022&quot;, 
                      i1=&gt;&quot; &quot;, i2=&gt;&quot; &quot;, 
                      value=&gt;$issn});
        $x-&gt;addfield({record=&gt;$num, 
                      field=&gt;&quot;245&quot;, 
                      i1=&gt;&quot;0&quot;, i2=&gt;&quot; &quot;, 
                      value=&gt;[a=&gt;$journaltitle]});
        $x-&gt;addfield({record=&gt;$num, 
                      field=&gt;&quot;260&quot;, 
                      i1=&gt;&quot; &quot;, i2=&gt;&quot; &quot;, 
                      value=&gt;[a=&gt;&quot;New York (N.Y.) :&quot;,
                              b=&gt;&quot;Dow Jones &amp; Company&quot;]});
        $x-&gt;addfield({record=&gt;$num,
                      field=&gt;&quot;710&quot;,
                      i1=&gt;&quot;2&quot;, i2=&gt;&quot; &quot;,
                      value=&gt;[a=&gt;&quot;Dow Jones Interactive.&quot;]});
        $x-&gt;addfield({record=&gt;$num,
                      field=&gt;&quot;856&quot;,
                      i1=&gt;&quot;4&quot;, i2=&gt;&quot; &quot;,
                      value=&gt;[u=&gt;&quot;<A HREF="http://www.djnr.com&quot">http://www.djnr.com&quot</A>;,
                              z=&gt;&quot;Connect&quot;]});
    }
    close INPUT_FILE;
    $x-&gt;output({file=&gt;&quot;&gt;dowjones.mrc&quot;,'format'=&gt;&quot;usmarc&quot;})
</PRE>
<LI>
<P>
Perhaps you have periodicals coming in that you want to order by location
and then title. MARC::Rec's get you out of some array indexing.

<P>
<PRE>    #!/usr/bin//perl
    use MARC 1.03;
</PRE>
<P>
<PRE>    my @newmarcs=@$marc[1..$#$marc]; # array slice.
    my @sortmarcs = sort by_loc_oclc @newmarcs;
    @marc[1..$#$marc] = @sortmarcs;
</PRE>
<P>
<PRE>    sub by_loc_title {
        my ($aloc,$atitle) = loc_title($a);
        my ($bloc,$btitle) = loc_title($b);
        return  $aloc cmp $bloc 
                      ||
              $atitle cmp $btitle;
    }
</PRE>
<P>
<PRE>    sub loc_title {
        my ($rec)=@_;
        my $n049 = $rec-&gt;getfirstvalue({field=&gt;040});
        my ($loc) = $n049=~/(ND\S+)/; # Or the first two letters of your OCLC
                                      # location.
</PRE>
<P>
<PRE>        my $title = $rec-&gt;getfirstvalue({field=&gt;100,delimiter=&gt;&quot; &quot;});
</PRE>
<P>
<PRE>        return ($loc,$title);
    }
</PRE>
</UL>
<P>
<HR>
<H1><A NAME="NOTES">NOTES</A></H1>
<P>
Please let us know if you run into any difficulties using MARC.pm--we'd be
happy to try to help. Also, please contact us if you notice any bugs, or if
you would like to suggest an improvement/enhancement. Email addresses are
listed at the bottom of this page.

<P>
Development of MARC.pm and other library oriented Perl utilities is
conducted on the Perl4Lib listserv. Perl4Lib is an open list and is an
ideal place to ask questions about MARC.pm. Subscription information is
available at <A
HREF="http://www.vims.edu/perl4lib">http://www.vims.edu/perl4lib</A>

<P>
Two global boolean variables are reserved for test and debugging. Both are
``0'' (off) by default. The <CODE>$TEST</CODE> variable disables internal error messages generated using <EM>Carp</EM>. It also overrides the date_stamp in the ``005'' field with a constant
``19960221075055.7''. It should only be used in the automatic test suite.
The <CODE>$DEBUG</CODE> variable adds verbose diagnostic messages. Since both variables are used
only in testing, <EM>MARC::Rec</EM> uses <CODE>$MARC::TEST</CODE>
and <CODE>$MARC::DEBUG</CODE> rather than define a second pair.

<P>
<HR>
<H1><A NAME="AUTHORS">AUTHORS</A></H1>
<P>
Chuck Bearden <A HREF="mailto:cbearden@rice.edu">cbearden@rice.edu</A>

<P>
Bill Birthisel <A
HREF="mailto:wcbirthisel@alum.mit.edu">wcbirthisel@alum.mit.edu</A>

<P>
Derek Lane <A HREF="mailto:dereklane@pobox.com">dereklane@pobox.com</A>

<P>
Charles McFadden <A HREF="mailto:chuck@vims.edu">chuck@vims.edu</A>

<P>
Ed Summers <A HREF="mailto:ed@cheetahmail.com">ed@cheetahmail.com</A>

<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
<CODE>perl(1),</CODE> <A
HREF="http://lcweb.loc.gov/marc">http://lcweb.loc.gov/marc</A>

<P>
<HR>
<H1><A NAME="COPYRIGHT">COPYRIGHT</A></H1>
<P>
Copyright (C) 1999,2000, Bearden, Birthisel, Lane, McFadden, and Summers.
All rights reserved. This module is free software; you can redistribute it
and/or modify it under the same terms as Perl itself. 23 April 2000.
Portions Copyright (C) 1999,2000, Duke University, Lane.

</BODY>

</HTML>
